/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ArduinoAST.jj */
/*@egen*/options
{
  IGNORE_CASE = false;
               
                 
}

PARSER_BEGIN(ArduinoAST)

import java.io.*;
import java.util.*;


/** ArduinoAST class */
public class ArduinoAST/*@bgen(jjtree)*/implements ArduinoASTTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTArduinoASTState jjtree = new JJTArduinoASTState();

/*@egen*/
	//public static Hashtable ST = new Hashtable();

	/** Main entry point */
	public static void main(String args[]) throws ParseException, FileNotFoundException {
		String temp;
		//STC temp2;

		if(args.length < 1) {
			// Prompt user for a file to compile
			System.out.println("Please pass in a filename of file to compile.");
			System.exit(1);
		}

		ArduinoAST parser = new ArduinoAST(new FileInputStream(args[0]));
		SimpleNode root = parser.Start();
		root.dump(" ");

		System.out.println();
		/*System.out.println("Symbol table:"); // Prints out a symbol tree

		Enumeration t = ST.keys();

		while (t.hasMoreElements()) {
			temp = (String).t.nextElement();
			temp2 = (STC)ST.get(temp);
			System.out.println(temp); // DOC HERE PLEASE

			if(temp2.type != null) {
				System.out.println(" type = " + temp2.type); // Print the type of the element
			}

			if(temp2.value != null) {
				System.out.println(" value = " + temp2.value); // Print the value of the element
			}
		}
	*/
		System.out.println(); // New line
		System.out.println("Progam: "); 

		PrintVisitor pv = new PrintVisitor(); // Instantiate the print visitor
		root.jjAccept(pv, null); // Print out the program

		/*System.out.println();
		System.out.println("Type Checking:");
		TypeCheckVisitor tc = new TypeCheckVisitor();
		root.jjAccept(tc, ST); // Print out any type errors
		*/
	}
}

PARSER_END(ArduinoAST)

/* Skip whitespace */
SKIP :
{
	" "
| "\t"
| "\n"
| "\r"	
| "\f"
}

/* Comments */
MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


TOKEN : /* Reserved words and literals */
{
	< BOOLEAN: "boolean" >
|	< DOUBLE: "double" >
|	< ELSE: "else" >
|	< ELSEIF: "elseif" >
|	< FALSE: "false" >
|	< FLOAT: "float" >
|	< IF: "if" >
|	< INT: "int" >
|	< NULL: "null" >
|	< STRING: "string" >
|	< TRUE: "true" >
|	< WHILE: "while" >
| 	< DO: "do" >
| 	< END: "end" >
|   < VOID: "void" >
|   < FUNCTION: "function" >
|   < RETURN: "return" >
}

/* Literals */
TOKEN : 
{
	< INTEGER_LITERAL: 
		<DECIMAL_LITERAL> (["l", "L"])?
	>

|	< #DECIMAL_LITERAL: ["1"-"9"] (["0" - "9"])* >

|	< FLOATING_POINT_LITERAL:
		  (["0" - "9"])+ "." (["0" - "9"])* (<EXPONENT>)? (["f", "F", "d", "D"])?
		| "." (["0" - "9"])+ <EXPONENT> (["f", "F", "d", "D"])?
		| (["0" - "9"])+ <EXPONENT> (["f", "F", "d", "D"])?
		| (["0" - "9"])+ (<EXPONENT>)? ["f", "F", "d", "D"]
	>

|	< #EXPONENT: ["e", "E"] (["+","-"])? (["0" - "9"])+ >

|	< CHARACTER_LITERAL:
		"'"
		(	(~["'","\\","\n","\r"])
			| ("\\"
				( ["n","t","b","r","f","\\","'","\""]
				| ["0" - "7"] ( ["0" - "7"] )?
				| ["0" -"3"] ["0" -"7"] ["0" - "7"] 
				)
			  )

		)	
		"'"
	>

|	< STRING_LITERAL:
		"\""
		(	(~["'","\\","\n","\r"])
			| ("\\"
				( ["n","t","b","r","f","\\","'","\""]
				| ["0" - "7"] ( ["0" - "7"] )?
				| ["0" -"3"] ["0" -"7"] ["0" - "7"] 
				)
			  )

		)*
		"\""
	>
}

/* Identifiers */
TOKEN :
{
	< IDENTIFIER: <LETTER> (<PART_LETTER>)* >

|	< #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
		"$",
		"A"-"Z",
		"_",
		"a"-"z"
      ]
	>

|	< #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z"
      ]

	>	
}

TOKEN : /* Seperators */
{
	< LPAREN: "(" >
|	< RPAREN: ")" >
|	< LBRACE: "{" >
|	< RBRACE: "}" >
|	< LBRACKET: "[" >
|	< RBRACKET: "]" >
|	< SEMICOLON: ";" >
|	< COMMA: "," >
|	< DOT: "." > 
}

TOKEN : /* Operators */
{
	< ASSIGN: "=" >
|	< GT: ">" >
|	< LT: "<" >
|	< COLON: ":" >
|	< EQ: "==" >
|	< LE: "<=" >
|	< GE: ">=" >
|	< NE: "!=" >
|	< SC_OR: "||" >
|	< SC_AND: "&&" >
|	< PLUS: "+" >
|	< MINUS: "-" >
|	< MULTIPLY: "*" >
|	< DIVIDE: "/" >
|	< MOD: "%" >
|	< SQRT: "sqrt" >
|	< POW: "^" >
|   < NOT: "!" >
}

/*TOKEN :
{
	< Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}*/

/*********************************************
*	LANGUAGE GRAMMAR STARTS HERE 							 *
*********************************************/



/** Root production */
/*void Input() :
{}
{
	( <Id> )+ <EOF> 
}*/

/* If statement grammar */

SimpleNode Start() :
{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/   
    "setup()" < LBRACE > [Statement()] < RBRACE > "loop()" < LBRACE > Statement()	 < RBRACE > <EOF>/*@bgen(jjtree)*/
                                                                                                         {
                                                                                                           jjtree.closeNodeScope(jjtn000, true);
                                                                                                           jjtc000 = false;
                                                                                                         }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

    //Statement()
}

/* Statement */
void Statement() : 
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
        try {
/*@egen*/   
	(    //EmptyStatement()
		    IfStatement()
		|   WhileStatement()
		|   VariableDeclaration()
		|   FunctionDeclaration()
		|   FunctionCall()
	)+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EmptyStatement() :
{/*@bgen(jjtree) EmptyStatement */
  ASTEmptyStatement jjtn000 = new ASTEmptyStatement(JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EmptyStatement */
    try {
/*@egen*/
    ";"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionDeclaration() :
{/*@bgen(jjtree) FunctionDeclaration */
  ASTFunctionDeclaration jjtn000 = new ASTFunctionDeclaration(JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionDeclaration */
    try {
/*@egen*/
    (<VOID> | PrimitiveTypes()) <FUNCTION> Name()<LPAREN>[Name()(<COMMA>Name())*]<RPAREN> <DO> Statement() [<RETURN> Name() <SEMICOLON>] <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void FunctionCall() :
{/*@bgen(jjtree) FunctionCall */
  ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionCall */
        try {
/*@egen*/
	Name()(<DOT>Name())*<LPAREN>[(Name() | Literal())(<COMMA>(Name() | Literal()))*]<RPAREN><SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ // Local function and call of method in other class
}

void IfStatement() :
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
    try {
/*@egen*/
    <IF> <LPAREN> BooleanExpression() <RPAREN> <DO> Statement() <END> [<ELSEIF> <LPAREN> Expression() <RPAREN> <DO> Statement() <END>] [<ELSE> <DO> Statement() <END>]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* While loop */
void WhileStatement() :
{/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
        try {
/*@egen*/
	<WHILE> <LPAREN> BooleanExpression() <RPAREN> <DO> Statement() <END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression() :
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	ArithmeticExpression()
|   BooleanExpression()
|   VariableDeclaration()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableDeclaration() :
{/*@bgen(jjtree) VariableDeclaration */
  ASTVariableDeclaration jjtn000 = new ASTVariableDeclaration(JJTVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDeclaration */
    try {
/*@egen*/
    PrimitiveTypes() Name() <ASSIGN> ((Literal() | Name()) (ArithmeticExpression() (Literal() | Name()))* | < LPAREN > BooleanExpression() < RPAREN >) <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void Name()             :
{/*@bgen(jjtree) Identifier */
 ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t=<IDENTIFIER>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PrimitiveTypes() :
{/*@bgen(jjtree) PrimitiveTypes */
  ASTPrimitiveTypes jjtn000 = new ASTPrimitiveTypes(JJTPRIMITIVETYPES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrimitiveTypes */
   try {
/*@egen*/
   NumberType()
|  <STRING>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void NumberType() :
{/*@bgen(jjtree) NumberType */
  ASTNumberType jjtn000 = new ASTNumberType(JJTNUMBERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NumberType */
        try {
/*@egen*/
	<INT>
|	<DOUBLE>
|	<FLOAT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ArithmeticExpression() :
{/*@bgen(jjtree) ArithmeticExpression */
  ASTArithmeticExpression jjtn000 = new ASTArithmeticExpression(JJTARITHMETICEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArithmeticExpression */
        try {
/*@egen*/
	(<PLUS> | <MINUS> | <MULTIPLY> | <DIVIDE> | <MOD> | <SQRT> | <POW>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void NumberSize() :
{/*@bgen(jjtree) NumberSize */
  ASTNumberSize jjtn000 = new ASTNumberSize(JJTNUMBERSIZE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NumberSize */
        try {
/*@egen*/
	<INTEGER_LITERAL>
|	<FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BooleanExpression() :
{/*@bgen(jjtree) BooleanExpression */
  ASTBooleanExpression jjtn000 = new ASTBooleanExpression(JJTBOOLEANEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BooleanExpression */
    try {
/*@egen*/
    RelationalExpression()
|   Name()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void RelationalExpression() :
{/*@bgen(jjtree) RelationalExpression */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationalExpression */
        try {
/*@egen*/

	Literal() ( ( <LT> | <GT> | <LE> | <GE> | <EQ> | <NE>) Literal() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Literal() :
{/*@bgen(jjtree) Literal */
  ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Literal */
    try {
/*@egen*/
    <INTEGER_LITERAL>
|	<FLOATING_POINT_LITERAL>
|	<CHARACTER_LITERAL>
|	<STRING_LITERAL>
|	BooleanLiteral()
|	NullLiteral()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



void BooleanLiteral() :
{/*@bgen(jjtree) BooleanLiteral */
  ASTBooleanLiteral jjtn000 = new ASTBooleanLiteral(JJTBOOLEANLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BooleanLiteral */
        try {
/*@egen*/
	<TRUE>
|	<FALSE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NullLiteral() :
{/*@bgen(jjtree) NullLiteral */
  ASTNullLiteral jjtn000 = new ASTNullLiteral(JJTNULLLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NullLiteral */
        try {
/*@egen*/
	<NULL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}