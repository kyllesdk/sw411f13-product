options
{
  IGNORE_CASE = false;
  MULTI = true;
  VISITOR = true;
}

PARSER_BEGIN(ArduinoLang)

import java.io.*;
import java.util.*;


/** ArduinoLang class */
public class ArduinoLang {
	public static Hashtable ST = new Hashtable();

	/** Main entry point */
	public static void main(String args[]) throws ParseException, FileNotFoundException {
		String temp;
		STC temp2;

		if(args.length < 1) {
			// Prompt user for a file to compile
			System.out.println("Please pass in a filename of file to compile.");
			System.exit(1);
		}

		ArduinoLang parser = new ArduinoLang(new FileInputStream(args[0]));
		SimpleNode root = parser.Program();

		System.out.println("Abstract Syntax Tree:");

		root.dump(" ");

		System.out.println("==========================================");
		System.out.println("Symbol table:"); // Prints out a symbol tree

		Enumeration t = ST.keys();

		while (t.hasMoreElements()) {
			temp = (String)t.nextElement();
			temp2 = (STC)ST.get(temp);
			System.out.println(temp); // DOC HERE PLEASE

			if(temp2.type != null) {
				System.out.println(" type = " + temp2.type); // Print the type of the element
			}

			if(temp2.value != null) {
				System.out.println(" value = " + temp2.value); // Print the value of the element
			}

			if(temp2.stringValue != null) {
				System.out.println(" value = " + temp2.stringValue); // Print the value of the element if it is a string
			}
		}
		
		System.out.println("=========================================="); // New line
		System.out.println("Progam: "); 

		PrintVisitor pv = new PrintVisitor(); // Instantiate the print visitor
		root.jjtAccept(pv, null); // Print out the program

		System.out.println();
		/*System.out.println("Type Checking:");
		TypeCheckVisitor tc = new TypeCheckVisitor();
		root.jjAccept(tc, ST); // Print out any type errors*/

	}
}

PARSER_END(ArduinoLang)

/* Skip whitespace */
SKIP :
{
	" "
| "\t"
| "\n"
| "\r"	
| "\f"
}

/* Comments */
MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


TOKEN : /* Reserved words and literals */
{
	< SETUP : "setup()" >
|	< LOOP: "loop()" >	
|	< CALL: "call" >
|	< INSTANTIATE: "instantiate" >
|	< BOOLEAN: "boolean" >
|	< DOUBLE: "double" >
|	< ELSE: "else" >
|	< ELSEIF: "elseif" >
|	< FALSE: "false" >
|	< FLOAT: "float" >
|	< IF: "if" >
|	< INT: "int" >
|	< NULL: "null" >
|	< STRING: "string" >
|	< TRUE: "true" >
|	< WHILE: "while" >
| 	< DO: "do" >
| 	< END: "end" >
|   < VOID: "void" >
|   < FUNCTION: "function" >
|   < RETURN: "return" >
}

/* Literals */
TOKEN : 
{
	< INTEGER_LITERAL: 
		<DECIMAL_LITERAL> (["l", "L"])?
	>

|	< #DECIMAL_LITERAL: ["0"-"9"] (["0" - "9"])* >

|	< FLOATING_POINT_LITERAL:
		  (["0" - "9"])+ "." (["0" - "9"])* (<EXPONENT>)? (["f", "F", "d", "D"])?
		| "." (["0" - "9"])+ <EXPONENT> (["f", "F", "d", "D"])?
		| (["0" - "9"])+ <EXPONENT> (["f", "F", "d", "D"])?
		| (["0" - "9"])+ (<EXPONENT>)? ["f", "F", "d", "D"]
	>

|	< #EXPONENT: ["e", "E"] (["+","-"])? (["0" - "9"])+ >

|	< CHARACTER_LITERAL:
		"'"
		(	(~["'","\\","\n","\r"])
			| ("\\"
				( ["n","t","b","r","f","\\","'","\""]
				| ["0" - "7"] ( ["0" - "7"] )?
				| ["0" -"3"] ["0" -"7"] ["0" - "7"] 
				)
			  )

		)	
		"'"
	>

|	< STRING_LITERAL:
		"\""
		(	(~["'","\\","\n","\r"])
			| ("\\"
				( ["n","t","b","r","f","\\","'","\""]
				| ["0" - "7"] ( ["0" - "7"] )?
				| ["0" -"3"] ["0" -"7"] ["0" - "7"] 
				)
			  )

		)*
		"\""
	>
}

/* Identifiers */
TOKEN :
{
	/*< IDENTIFIER: <LETTER> (<PART_LETTER>)* >*/
	< #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
		"$",
		"A"-"Z",
		"_",
		"a"-"z"
      ]
	>

|	< #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z"
      ]

	>	
}

TOKEN : /* Operators */
{
	< ASSIGN: "=" >
|	< COLON: ":" >
|	< BOOL_OP: "AND" | "||" | "<=" | ">=" | "NOTEQUALS" | "EQUALS" | "NOT">
|	< GT: ">" >
|	< LT: "<" >
|	< ADD_OP: "+" | "-" >
|	< MULTIPLY: "*" >
|	< DIVISION: "/" >
|	< MOD: "%" >
| 	< POW: "^" >
|	< EMPTY: "" >
|	< HASHTAG: "#" >
}


TOKEN : /* Seperators */
{
	< LPAREN: "(" >
|	< RPAREN: ")" >
|	< LBRACE: "{" >
|	< RBRACE: "}" >
|	< LBRACKET: "[" >
|	< RBRACKET: "]" >
|	< SEMICOLON: ";" >
|	< COMMA: "," >
|	< DOT: "." > 
|	< ID: ["a"-"z","A"-"Z","."] ( ["a"-"z","A"-"Z","0"-"9", "."] )* >
//|	< PARAMETER: ["(","a"-"z","A"-"Z","0"-"9","\"",","] ( ["a"-"z","A"-"Z","0"-"9","\"" ,","] )* [")"] >
}

/*TOKEN :
{
	< Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}*/

/*********************************************
*	LANGUAGE GRAMMAR STARTS HERE 							 *
*********************************************/



/** Root production */
/*void Input() :
{}
{
	( <Id> )+ <EOF> 
}*/

/* If statement grammar */

SimpleNode Program() : {}
{   
	ProgramTop() ProgramContent() <EOF> {return jjtThis;}
}

void ProgramContent() #ProgramContent : {Token t;}
{
	ProgramSetup() ProgramLoop()
}

void ProgramTop() #ProgramTop : {Token t;}
{
	(
	t = <HASHTAG> Identifier() <LT> Identifier() <GT> {jjtThis.value = t.image;} #ProgramLibInclude(2)
	| ClassInstantiation()
	)*
}

void ProgramStart() #void : {Token t;}
{
	(ProgramTop() ProgramSetup() ProgramLoop())  #ProgramStart(2)
}

void ProgramSetup() #void : {Token t;}
{
	<VOID> t = <SETUP> <DO> [Statements()] <END> {jjtThis.value = t.image;} #ProgramSetup(1)
}

void ProgramLoop() #void : {Token t;}
{
	<VOID> t = <LOOP> <DO> [Statements()] <END> {jjtThis.value = t.image;} #ProgramLoop(1)
}

void Statements() #void : {}
{
	(SimpleStatement() [Statements() #Statements(2)])
}

void SimpleStatement() #void : {}
{
	(Expression()) | (Declaration() | FunctionCall() | IfStatement() | WhileStatement() | ClassInstantiation())
}

void Declaration() #Declaration : {Token t; String name; Token value; String stringText;}
{
	t = <INT> name = Identifier() <ASSIGN> (Expression())* <SEMICOLON> {jjtThis.value = t.image;}
	| t = <FLOAT> name = Identifier() <ASSIGN> (Expression())* <SEMICOLON> {jjtThis.value = t.image;}
	| t = <STRING> name = Identifier() <ASSIGN> (Expression())* <SEMICOLON> {jjtThis.value = t.image;}
}
	
String DeclarationLogic() #void : {Token t;}
{
	<ASSIGN> t = Number() {jjtThis.value = t.image; return t.image;} #DeclarationLogic(1)
}

/**
* Expression
* @accepts
* @accepts 
**/
void Expression() #Expression : {Token t;}
{
	// Term()
	// (
	// 	(t = <ADD_OP> Term() {jjtThis.value = t.image;} #Add_op(2))
	// )*
	(<LPAREN> Expression() <RPAREN>
	|
	Term()(
		(t = <ADD_OP> Expression()){jjtThis.value = t.image;} #Add_op(2)
		| (t = <MULTIPLY> Expression()){jjtThis.value = t.image;} #Add_op(2)
		| (t = <DIVISION> Expression()){jjtThis.value = t.image;} #Add_op(2)
		| (t = <POW> Expression()){jjtThis.value = t.image;} #Add_op(2)
		| (t = <LPAREN> Expression()<RPAREN> {jjtThis.value = t.image;} #Add_op(2))
		| (t = <MOD> Expression()){jjtThis.value = t.image;} #Add_op(2)
	)*
	)
}

/**
* If-statement
*
**/
void IfStatement() #If_stm : {Token t;}
{
	(t = <IF><LPAREN>BooleanExpression()<RPAREN> <DO> Statements() <END> (ElseifStatement())* [ElseStatement()] {jjtThis.value = t.image;})
}

/**
* Elseif-statement
*
**/
void ElseifStatement() #ElsIf_stm : {Token t;}
{
	(t = <ELSEIF><LPAREN>BooleanExpression()<RPAREN> <DO> Statements() <END>{jjtThis.value = t.image;})
}

/**
* Else statement
*
**/
void ElseStatement() #void : {Token t;}
{
	(t = <ELSE> <DO> Statements() <END>) {jjtThis.value = t.image;} #Els_stm(1)
}

/**
* While statement
*
**/
void WhileStatement() #void : {Token t;}
{
	(t = <WHILE> <LPAREN> BooleanExpression() <RPAREN> <DO> Statements() <END>) {jjtThis.value = t.image;} #WhileStatement(2)
}

void BooleanExpression() #void : {Token t;}
{
	Expression()( 
	t = <BOOL_OP> Expression() {jjtThis.value = t.image;} #Bool_op(2)
	| t = <GT> Expression() {jjtThis.value = t.image;} #Bool_op(2)
	| t = <LT> Expression() {jjtThis.value = t.image;} #Bool_op(2)
	)*
}

void FunctionCall() #FunctionCall : {Token t; String name;}
{
	<CALL> name = Identifier() (Identifier())* <LPAREN>(Parameters())*<RPAREN><SEMICOLON>
}

void ClassInstantiation() #ClassInstantiation : {}
{
	<INSTANTIATE> Identifier() (Identifier())* <LPAREN>(Parameters())*<RPAREN><SEMICOLON>
}

void Parameters() #Parameter : {Token t; String text;}
{
	((t = Number()((("," | <MOD> | <MULTIPLY> | <DIVISION> | <ADD_OP>) Parameters())*){jjtThis.value = t;}
|	(text = StringText()("," Parameters())*){jjtThis.value = text;}
|	(text = Identifier()("," Parameters())*){jjtThis.value = text;}
/*|	(FunctionCall()(("," | <MOD> | <MULTIPLY> | <DIVISION> | <ADD_OP>) Parameters())*)*/
))
}

/**
* Term
* @accepts 
**/
void Term() #void : {Token t;}
{
/*	<NOT> Factor() #Not_op(1)
	| Factor() (t = <MULTIPLY> Factor() {jjtThis.value = t.image;} #Mult_op(2))*
*/
	(Number() | Identifier())
}

/**
* Factor
* @accepts "("Expression")""
* @accepts Number
* @accepts Identifier
**/
void Factor() #Factor : {}
{
	/*(<LPAREN> Expression() #Expression(1) <RPAREN>
	| Number()
	| Identifier()
	)*/
	Number()
	| Identifier()
}

/**
* Number
* @accepts <INTEGER_LITERAL>
* @accepts <FLOATING_POINT_LITERAL>
**/
Token Number() : {Token t;}
{
	(
		t = <INTEGER_LITERAL> {jjtThis.value = t.image; return t;}
		| t = <FLOATING_POINT_LITERAL> {jjtThis.value = t; return t;}
	)
}

String StringText() : {Token t;}
{
	t = <STRING_LITERAL> {jjtThis.value = t.image; return t.image;}
}

/**
* Identifier
* @accepts <ID> (a-z, A-Z)
**/
String Identifier() : {Token t;}
{
	t = <ID> {jjtThis.value = t.image; return t.image;}
}


