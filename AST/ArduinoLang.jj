/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ArduinoLang.jj */
/*@egen*/options
{
  IGNORE_CASE = false;
               
                 
  DEBUG_PARSER = true;
}

PARSER_BEGIN(ArduinoLang)

import java.io.*;
import java.util.*;


/** ArduinoLang class */
public class ArduinoLang/*@bgen(jjtree)*/implements ArduinoLangTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTArduinoLangState jjtree = new JJTArduinoLangState();

/*@egen*/
	public static Hashtable ST = new Hashtable();

	/** Main entry point */
	public static void main(String args[]) throws ParseException, FileNotFoundException {
		String temp;
		STC temp2;

		if(args.length < 1) {
			// Prompt user for a file to compile
			System.out.println("Please pass in a filename of file to compile.");
			System.exit(1);
		}

		ArduinoLang parser = new ArduinoLang(new FileInputStream(args[0]));
		SimpleNode root = parser.Program();

		System.out.println("Abstract Syntax Tree:");

		root.dump(" ");

		System.out.println("==========================================");
		System.out.println("Symbol table:"); // Prints out a symbol tree

		Enumeration t = ST.keys();

		while (t.hasMoreElements()) {
			temp = (String)t.nextElement();
			temp2 = (STC)ST.get(temp);
			System.out.print("Name: ");
			System.out.println(temp); // DOC HERE PLEASE

			if(temp2.type != null) {
				System.out.println(" type = " + temp2.type); // Print the type of the element
			}

			System.out.println("");
		}
		
		System.out.println("=========================================="); // New line
		System.out.println("Progam: "); 

		PrintVisitor pv = new PrintVisitor(); // Instantiate the print visitor
		root.jjtAccept(pv, null); // Print out the program


		System.out.println("=========================================="); // New line
		System.out.println();
		System.out.println("Type Checking:");
		TypeCheckVisitor tc = new TypeCheckVisitor();
		root.jjtAccept(tc, ST); // Print out any type errors*/

	}
}

PARSER_END(ArduinoLang)

/* Skip whitespace */
SKIP :
{
	" "
| "\t"
| "\n"
| "\r"	
| "\f"
}

/* Comments */
MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


TOKEN : /* Reserved words and literals */
{
	< SETUP : "setup()" >
|	< LOOP: "loop()" >	
|	< CALL: "call" >
|	< INSTANTIATE: "instantiate" >
|	< BOOLEAN: "boolean" >
|	< DOUBLE: "double" >
|	< ELSE: "else" >
|	< ELSEIF: "elseif" >
|	< FLOAT: "float" >
|	< IF: "if" >
|	< INT: "int" >
|	< NULL: "null" >
|	< STRING: "string" >
|	< WHILE: "while" >
| 	< DO: "do" >
| 	< END: "end" >
|   < VOID: "void" >
|   < FUNCTION: "function" >
|   < RETURN: "return" >
}

/* Literals */
TOKEN : 
{
	< INTEGER_LITERAL: 
		<DECIMAL_LITERAL> (["l", "L"])?
		| <MINUS><DECIMAL_LITERAL> (["l", "L"])?
	>
|	< #DECIMAL_LITERAL: ["0"-"9"] (["0" - "9"])* >

|	< FLOATING_POINT_LITERAL:
		  (["0" - "9"])+ "." (["0" - "9"])* (<EXPONENT>)? (["f", "F", "d", "D"])?
		| "." (["0" - "9"])+ <EXPONENT> (["f", "F", "d", "D"])?
		| (["0" - "9"])+ <EXPONENT> (["f", "F", "d", "D"])?
		| (["0" - "9"])+ (<EXPONENT>)? ["f", "F", "d", "D"]



		| <MINUS>(["0" - "9"])+ "." (["0" - "9"])* (<EXPONENT>)? (["f", "F", "d", "D"])?
		| <MINUS>(["0" - "9"])+ <EXPONENT> (["f", "F", "d", "D"])?
		| <MINUS>(["0" - "9"])+ (<EXPONENT>)? ["f", "F", "d", "D"]
	>

|	< #EXPONENT: ["e", "E"] (["+","-"])? (["0" - "9"])+ > // Bruger vi den?

|	< CHARACTER_LITERAL:
		"'"
		(	(~["'","\\","\n","\r"])
			| ("\\"
				( ["n","t","b","r","f","\\","'","\""]
				| ["0" - "7"] ( ["0" - "7"] )?
				| ["0" -"3"] ["0" -"7"] ["0" - "7"] 
				)
			  )

		)	
		"'"
	>

|	< STRING_LITERAL:
		"\""
		(	(~["'","\\","\n","\r"])
			| ("\\"
				( ["n","t","b","r","f","\\","'","\""]
				| ["0" - "7"] ( ["0" - "7"] )?
				| ["0" -"3"] ["0" -"7"] ["0" - "7"] 
				)
			  )

		)*
		"\""
	>
}

/* Identifiers */
TOKEN :
{
	/*< IDENTIFIER: <LETTER> (<PART_LETTER>)* >*/

	< #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
		"A"-"Z",
		"_",
		"a"-"z"
      ]
	>

|	< #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z"
      ]

	>	
}

TOKEN : /* Operators */
{
	< ASSIGN: "=" >
|	< COLON: ":" >
|	< BOOL_OP: "AND" | "OR" | "<=" | ">=" | "NOTEQUALS" | "EQUALS" | "NOT">
|   < LT: "<" >
|   < GT: ">" >
|	< ADD_OP: "+" >
|	< MINUS: "-" >
|	< MULTIPLY: "*" >
|	< DIVISION: 
		"/" ["1"-"9"] (["0" - "9"])* 
		| "/" <MINUS>["1"-"9"] (["0" - "9"])* >
|	< SQRT: "SQRT" >
|	< POSITIVENUMBER: "["["0"-"9"] (["0" - "9"])*"]" >
|	< MOD: "%" >
| 	< POW: "^" >
|	< HASHTAG: "#" >
}


TOKEN : /* Seperators */
{
	< LPAREN: "(" >
|	< RPAREN: ")" >
|	< LBRACE: "{" >
|	< RBRACE: "}" >
|	< LBRACKET: "[" >
|	< RBRACKET: "]" >
|	< SEMICOLON: ";" >
|	< COMMA: "," >
|	< DOT: "." > 
|	< ID: ["a"-"z","A"-"Z","."] ( ["a"-"z","A"-"Z","0"-"9", "."] )* >
|	< FUNCTIONCALLNAME: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* "()" >
}

/*********************************************
*	LANGUAGE GRAMMAR STARTS HERE 							 *
*********************************************/

// Starting Simple node (program starts here), and runs until EOF is reached
SimpleNode Program() : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
        try {
/*@egen*/   
	ProgramTop() ProgramContent() <EOF>/*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                            }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* ProgramContents is all the program besides the definitions and instantiations that can occur in the top
**/
void ProgramContent()                 : {/*@bgen(jjtree) ProgramContent */
  ASTProgramContent jjtn000 = new ASTProgramContent(JJTPROGRAMCONTENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ProgramContent */
        try {
/*@egen*/
	ProgramSetup() ProgramLoop()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Alows the top of the program to be made
* @allows definitions to be made (#DEFINE ...)
* @allows class instantiations (instantiate CLASSNAME variable = ..)
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void ProgramTop()             : {/*@bgen(jjtree) ProgramTop */
                                 ASTProgramTop jjtn000 = new ASTProgramTop(JJTPROGRAMTOP);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ProgramTop */
        try {
/*@egen*/
	(
	t = <HASHTAG> Identifier() <LT> Identifier() <GT>/*@bgen(jjtree) #ProgramLibInclude( 2) */
                                                          {
                                                            ASTProgramLibInclude jjtn001 = new ASTProgramLibInclude(JJTPROGRAMLIBINCLUDE);
                                                            boolean jjtc001 = true;
                                                            jjtree.openNodeScope(jjtn001);
                                                          }
                                                          try {
/*@egen*//*@bgen(jjtree)*/
                                                          {
                                                            jjtree.closeNodeScope(jjtn001,  2);
                                                            jjtc001 = false;
                                                          }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                                          } finally {
                                                            if (jjtc001) {
                                                              jjtree.closeNodeScope(jjtn001,  2);
                                                            }
                                                          }
/*@egen*/                      
	| ClassInstantiation()
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*void ProgramStart() #void : {Token t;}
{
	(ProgramTop() ProgramSetup() ProgramLoop())  #ProgramStart(2)
}
*/

/**
* ProgramSetup is defining how to Setup() function of a program should be made
* @accepts void Setup() do STATEMENT end
* @Hint Statements are optional so that the setup() function can be empty
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void ProgramSetup()       : {Token t;}
{
	<VOID> t = <SETUP> <DO> [Statements()] <END>/*@bgen(jjtree) #ProgramSetup( 1) */
                                                     {
                                                       ASTProgramSetup jjtn001 = new ASTProgramSetup(JJTPROGRAMSETUP);
                                                       boolean jjtc001 = true;
                                                       jjtree.openNodeScope(jjtn001);
                                                     }
                                                     try {
/*@egen*//*@bgen(jjtree)*/
                                                     {
                                                       jjtree.closeNodeScope(jjtn001,  1);
                                                       jjtc001 = false;
                                                     }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                                     } finally {
                                                       if (jjtc001) {
                                                         jjtree.closeNodeScope(jjtn001,  1);
                                                       }
                                                     }
/*@egen*/                 
}

/**
* ProgramLoop defines how the Loop() function of a program must be defined
* @accepts void Loop() do STATEMENT end
* @Hint Satements are optional so that the loop() function can be empty
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void ProgramLoop()       : {Token t;}
{
	<VOID> t = <LOOP> <DO> [Statements()] <END>/*@bgen(jjtree) #ProgramLoop( 1) */
                                                    {
                                                      ASTProgramLoop jjtn001 = new ASTProgramLoop(JJTPROGRAMLOOP);
                                                      boolean jjtc001 = true;
                                                      jjtree.openNodeScope(jjtn001);
                                                    }
                                                    try {
/*@egen*//*@bgen(jjtree)*/
                                                    {
                                                      jjtree.closeNodeScope(jjtn001,  1);
                                                      jjtc001 = false;
                                                    }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                                    } finally {
                                                      if (jjtc001) {
                                                        jjtree.closeNodeScope(jjtn001,  1);
                                                      }
                                                    }
/*@egen*/                
}

/**
* Statements
* @allows the user to make more than one statement
**/
void Statements()       : {}
{
	(SimpleStatement() [/*@bgen(jjtree) #Statements( 2) */
                            {
                              ASTStatements jjtn001 = new ASTStatements(JJTSTATEMENTS);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                            }
                            try {
/*@egen*/Statements()/*@bgen(jjtree)*/
                            } catch (Throwable jjte001) {
                              if (jjtc001) {
                                jjtree.clearNodeScope(jjtn001);
                                jjtc001 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte001 instanceof RuntimeException) {
                                throw (RuntimeException)jjte001;
                              }
                              if (jjte001 instanceof ParseException) {
                                throw (ParseException)jjte001;
                              }
                              throw (Error)jjte001;
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                              }
                            }
/*@egen*/               ])
}

/**
* SimpleStatement is defining what a statement can consist of
* @accepts Expression() e.g. c = a + b;
* @accepts Declarations e.g. int a = 10; int b = 2;
* @accepts Function calls e.g. call HelloWorld();
* @accepts If-statements e.g. if(BOOLEAN) do STATEMENT end
* @accepts While loops e.g. while(BOOLEAN) do STATEMENT end
* @accepts Class instantiations e.g. instantiate CLASSNAME VARIABLE = ...
**/
void SimpleStatement()       : {}
{
	(Expression() | Declaration() | FunctionCall() | IfStatement() | WhileStatement() | ClassInstantiation())
}

/**
* Declaration Defines how a declaration must be made, and what types is allowed
* @accepts int NAME = EXPRESSION*; The value has to be a number that is following the rules of an integer. Decimals is not allowed
* @accepts float NAME = EXPRESSION*; The value has to be a number that is folowing the rules of an integer. Decimals is allowed.
* @accepts string NAME = EXPRESSION*; The value has to be text or numbers that follows the string_literal rules.
* @param Token t, this is the token that is sent to the PrintVisitor
* @param String name, this is the name that is sent to the STC class
* @Param Token value, this is the value of the declaration that is sent to the STC Class. This is used for int, and float
* @param String stringText, is used almost the same as Token value, but this is sending the text-value to STC class
**/
void Declaration()              : {/*@bgen(jjtree) Declaration */
                                   ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String name; Token value; String stringText;}
{/*@bgen(jjtree) Declaration */
        try {
/*@egen*/
	t = <INT>  name =Identifier() <ASSIGN> (Expression())* <SEMICOLON>/*@bgen(jjtree)*/
                                                                           {
                                                                             jjtree.closeNodeScope(jjtn000, true);
                                                                             jjtc000 = false;
                                                                           }
/*@egen*/ {jjtn000.value = t.image; ST.put(name, new STC("int", name));}
	| t = <FLOAT> name = Identifier() <ASSIGN> (Expression())* <SEMICOLON>/*@bgen(jjtree)*/
                                                                               {
                                                                                 jjtree.closeNodeScope(jjtn000, true);
                                                                                 jjtc000 = false;
                                                                               }
/*@egen*/ {jjtn000.value = t.image; ST.put(name, new STC("float", name));}
	| t = <STRING> name = Identifier() <ASSIGN> (StringText())*  <SEMICOLON>/*@bgen(jjtree)*/
                                                                                 {
                                                                                   jjtree.closeNodeScope(jjtn000, true);
                                                                                   jjtc000 = false;
                                                                                 }
/*@egen*/ {jjtn000.value = t.image; ST.put(name, new STC("string", name));}
	| t = <BOOLEAN> name = Identifier() <ASSIGN> BooleanNumber() <SEMICOLON>/*@bgen(jjtree)*/
                                                                                {
                                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                                  jjtc000 = false;
                                                                                }
/*@egen*/{jjtn000.value = t.image; ST.put(name, new STC("boolean", name));}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
	
/**String DeclarationLogic() #void : {Token t;}
{
	<ASSIGN> t = Number() {jjtThis.value = t.image; return t.image;} #DeclarationLogic(1)
}*/

/**
* Expressions
* @accepts TERM (+ | -) EXPRESSION, plus and minus operation
* @accepts TERM  * EXPRESSION, multiply operation
* @accepts TERM / EXPRESSION, division operation
* @accepts TERM ^ EXPRESSION, power a number e.g. 2^2
* @accepts TERM (EXPRESSION), parenthesis can be used
* @accepts TERM % EXPRESSION, the modulus operation
* @accepts TERM SQRT(POSITIVENUMBER) | SQRT(POSITIVENUMBER), the square root operation
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void Expression()             : {/*@bgen(jjtree) Expression */
                                 ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	(<LPAREN> Expression() <RPAREN>
	|	FunctionCallAsExpression()
	|	Sqrt_op()
	|	Term()(
			(t = <ADD_OP> Expression())/*@bgen(jjtree) #Add_op( 2) */
                                                   {
                                                     ASTAdd_op jjtn001 = new ASTAdd_op(JJTADD_OP);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                   }
                                                   try {
/*@egen*//*@bgen(jjtree)*/
                                                   {
                                                     jjtree.closeNodeScope(jjtn001,  2);
                                                     jjtc001 = false;
                                                   }
/*@egen*/{jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                                   } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  2);
                                                     }
                                                   }
/*@egen*/           
			| (t = <MINUS> Expression())/*@bgen(jjtree) #Add_op( 2) */
                                                    {
                                                      ASTAdd_op jjtn002 = new ASTAdd_op(JJTADD_OP);
                                                      boolean jjtc002 = true;
                                                      jjtree.openNodeScope(jjtn002);
                                                    }
                                                    try {
/*@egen*//*@bgen(jjtree)*/
                                                    {
                                                      jjtree.closeNodeScope(jjtn002,  2);
                                                      jjtc002 = false;
                                                    }
/*@egen*/{jjtn002.value = t.image;}/*@bgen(jjtree)*/
                                                    } finally {
                                                      if (jjtc002) {
                                                        jjtree.closeNodeScope(jjtn002,  2);
                                                      }
                                                    }
/*@egen*/           
			| (t = <MULTIPLY> Expression())/*@bgen(jjtree) #Add_op( 2) */
                                                       {
                                                         ASTAdd_op jjtn003 = new ASTAdd_op(JJTADD_OP);
                                                         boolean jjtc003 = true;
                                                         jjtree.openNodeScope(jjtn003);
                                                       }
                                                       try {
/*@egen*//*@bgen(jjtree)*/
                                                       {
                                                         jjtree.closeNodeScope(jjtn003,  2);
                                                         jjtc003 = false;
                                                       }
/*@egen*/{jjtn003.value = t.image;}/*@bgen(jjtree)*/
                                                       } finally {
                                                         if (jjtc003) {
                                                           jjtree.closeNodeScope(jjtn003,  2);
                                                         }
                                                       }
/*@egen*/           
			| Divide_op()
			| (t = <POW><LPAREN>Expression()<RPAREN>)/*@bgen(jjtree) #Add_op( 2) */
                                                                 {
                                                                   ASTAdd_op jjtn004 = new ASTAdd_op(JJTADD_OP);
                                                                   boolean jjtc004 = true;
                                                                   jjtree.openNodeScope(jjtn004);
                                                                 }
                                                                 try {
/*@egen*//*@bgen(jjtree)*/
                                                                 {
                                                                   jjtree.closeNodeScope(jjtn004,  2);
                                                                   jjtc004 = false;
                                                                 }
/*@egen*/{jjtn004.value = t.image;}/*@bgen(jjtree)*/
                                                                 } finally {
                                                                   if (jjtc004) {
                                                                     jjtree.closeNodeScope(jjtn004,  2);
                                                                   }
                                                                 }
/*@egen*/           
			| (t = <LPAREN> Expression()<RPAREN>/*@bgen(jjtree) #Add_op( 2) */
                                                             {
                                                               ASTAdd_op jjtn005 = new ASTAdd_op(JJTADD_OP);
                                                               boolean jjtc005 = true;
                                                               jjtree.openNodeScope(jjtn005);
                                                             }
                                                             try {
/*@egen*//*@bgen(jjtree)*/
                                                             {
                                                               jjtree.closeNodeScope(jjtn005,  2);
                                                               jjtc005 = false;
                                                             }
/*@egen*/ {jjtn005.value = t.image;}/*@bgen(jjtree)*/
                                                             } finally {
                                                               if (jjtc005) {
                                                                 jjtree.closeNodeScope(jjtn005,  2);
                                                               }
                                                             }
/*@egen*/           )
			| (t = <MOD> Expression())/*@bgen(jjtree) #Add_op( 2) */
                                                  {
                                                    ASTAdd_op jjtn006 = new ASTAdd_op(JJTADD_OP);
                                                    boolean jjtc006 = true;
                                                    jjtree.openNodeScope(jjtn006);
                                                  }
                                                  try {
/*@egen*//*@bgen(jjtree)*/
                                                  {
                                                    jjtree.closeNodeScope(jjtn006,  2);
                                                    jjtc006 = false;
                                                  }
/*@egen*/{jjtn006.value = t.image;}/*@bgen(jjtree)*/
                                                  } finally {
                                                    if (jjtc006) {
                                                      jjtree.closeNodeScope(jjtn006,  2);
                                                    }
                                                  }
/*@egen*/           
			| Sqrt_op() [Expression()]
			| FunctionCallAsExpression()
	)*
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FunctionCallAsExpression()                           : {/*@bgen(jjtree) FunctionCallAsExpression */
                                                             ASTFunctionCallAsExpression jjtn000 = new ASTFunctionCallAsExpression(JJTFUNCTIONCALLASEXPRESSION);
                                                             boolean jjtc000 = true;
                                                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) FunctionCallAsExpression */
        try {
/*@egen*/
	(t = <FUNCTIONCALLNAME>[Expression()])/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                               }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Divide operation
* @accepts /NUMBER (besides 0)
* @hint This is used fir the Expression method
*/
void Divide_op()            : {/*@bgen(jjtree) Divide_op */
                               ASTDivide_op jjtn000 = new ASTDivide_op(JJTDIVIDE_OP);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Divide_op */
        try {
/*@egen*/
	(t = <DIVISION> [Expression()])/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/{jjtn000.value = t.image;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* @accepts "("POSITIVENUMBER")" (also 0)
* @hint This is ised in the Expression
*/
void Sqrt_op()          : {/*@bgen(jjtree) Sqrt_op */
                           ASTSqrt_op jjtn000 = new ASTSqrt_op(JJTSQRT_OP);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Sqrt_op */
        try {
/*@egen*/
	(<SQRT> t =<POSITIVENUMBER> [Expression()])/*@bgen(jjtree)*/
                                                   {
                                                     jjtree.closeNodeScope(jjtn000, true);
                                                     jjtc000 = false;
                                                   }
/*@egen*/{jjtn000.value = t.image;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* If-statement
* @accepts if(BOOLEAN) do STATEMENT end (ELSEIF)* [ELSE]
* @param Token t, this is the token that is sent to the PrintVisitor
* @hint The elseif statement is concatenated so that it can occur 0+ times
* @hint The else statement is set as optional
**/
void IfStatement()         : {/*@bgen(jjtree) If_stm */
                              ASTIf_stm jjtn000 = new ASTIf_stm(JJTIF_STM);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) If_stm */
        try {
/*@egen*/
	(t = <IF><LPAREN>BooleanExpression()<RPAREN> <DO> Statements() <END> (ElseifStatement())* [ElseStatement()]/*@bgen(jjtree)*/
                                                                                                                    {
                                                                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                                                                      jjtc000 = false;
                                                                                                                    }
/*@egen*/ {jjtn000.value = t.image;})/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Elseif-statement
* @accepts elseif(BOOLEAN) do STATEMENT end
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void ElseifStatement()            : {/*@bgen(jjtree) ElsIf_stm */
                                     ASTElsIf_stm jjtn000 = new ASTElsIf_stm(JJTELSIF_STM);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ElsIf_stm */
        try {
/*@egen*/
	(t = <ELSEIF><LPAREN>BooleanExpression()<RPAREN> <DO> Statements() <END>/*@bgen(jjtree)*/
                                                                                {
                                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                                  jjtc000 = false;
                                                                                }
/*@egen*/{jjtn000.value = t.image;})/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Else statement
* @accepts else do STATEMENT end
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void ElseStatement()       : {Token t;}
{
	(t = <ELSE> <DO> Statements() <END>)/*@bgen(jjtree) #Els_stm( 1) */
                                             {
                                               ASTEls_stm jjtn001 = new ASTEls_stm(JJTELS_STM);
                                               boolean jjtc001 = true;
                                               jjtree.openNodeScope(jjtn001);
                                             }
                                             try {
/*@egen*//*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn001,  1);
                                               jjtc001 = false;
                                             }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                             } finally {
                                               if (jjtc001) {
                                                 jjtree.closeNodeScope(jjtn001,  1);
                                               }
                                             }
/*@egen*/            
}

/**
* While statement - This is the only loop functionality in the language
* @accepts while(BOOLEAN) do STATEMENT end
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void WhileStatement()       : {Token t;}
{
	(t = <WHILE> <LPAREN> BooleanExpression() <RPAREN> <DO> Statements() <END>)/*@bgen(jjtree) #WhileStatement( 2) */
                                                                                    {
                                                                                      ASTWhileStatement jjtn001 = new ASTWhileStatement(JJTWHILESTATEMENT);
                                                                                      boolean jjtc001 = true;
                                                                                      jjtree.openNodeScope(jjtn001);
                                                                                    }
                                                                                    try {
/*@egen*//*@bgen(jjtree)*/
                                                                                    {
                                                                                      jjtree.closeNodeScope(jjtn001,  2);
                                                                                      jjtc001 = false;
                                                                                    }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                                                                    } finally {
                                                                                      if (jjtc001) {
                                                                                        jjtree.closeNodeScope(jjtn001,  2);
                                                                                      }
                                                                                    }
/*@egen*/                   
}

/**
* BooleanExpression defines what boolean expressions consist of
* @accepts EXPRESSION (AND | OR | <= | >= | NOTEQUALS | EQUALS | NOT) EXPRESSION e.g. (a AND c) NOTEQUALS c
* @accepts EXPRESSION > EXPRESSION e.g. a > b
* @accepts EXPRESSION < EXPRESSION e.g. a < b
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void BooleanExpression()       : {Token t;}
{
	(<LPAREN>BooleanExpression()<RPAREN>
	| Expression()(
		t = <BOOL_OP> Expression()/*@bgen(jjtree) #Bool_op( 2) */
                                           {
                                             ASTBool_op jjtn001 = new ASTBool_op(JJTBOOL_OP);
                                             boolean jjtc001 = true;
                                             jjtree.openNodeScope(jjtn001);
                                           }
                                           try {
/*@egen*//*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn001,  2);
                                             jjtc001 = false;
                                           }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                           } finally {
                                             if (jjtc001) {
                                               jjtree.closeNodeScope(jjtn001,  2);
                                             }
                                           }
/*@egen*/            
	|	t = <LT> Expression()/*@bgen(jjtree) #Bool_op( 2) */
                                      {
                                        ASTBool_op jjtn002 = new ASTBool_op(JJTBOOL_OP);
                                        boolean jjtc002 = true;
                                        jjtree.openNodeScope(jjtn002);
                                      }
                                      try {
/*@egen*//*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn002,  2);
                                        jjtc002 = false;
                                      }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                                      } finally {
                                        if (jjtc002) {
                                          jjtree.closeNodeScope(jjtn002,  2);
                                        }
                                      }
/*@egen*/            
	|	t = <GT> Expression()/*@bgen(jjtree) #Bool_op( 2) */
                                      {
                                        ASTBool_op jjtn003 = new ASTBool_op(JJTBOOL_OP);
                                        boolean jjtc003 = true;
                                        jjtree.openNodeScope(jjtn003);
                                      }
                                      try {
/*@egen*//*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn003,  2);
                                        jjtc003 = false;
                                      }
/*@egen*/ {jjtn003.value = t.image;}/*@bgen(jjtree)*/
                                      } finally {
                                        if (jjtc003) {
                                          jjtree.closeNodeScope(jjtn003,  2);
                                        }
                                      }
/*@egen*/            

	)*)
}

/**
* FunctionCall defines how a function must be called
* @accepts call FUNCTIONNAME(PARAMETERS);
* @hint function calls can consist of multiple calls seperated by a "." e.g. System.out.print(PAMETERS);
* @hint a function can consist of zero parameters
* @param Token t, this is the token that is sent to the PrintVisitor
**/
void FunctionCall()               : {/*@bgen(jjtree) FunctionCall */
                                     ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String name;}
{/*@bgen(jjtree) FunctionCall */
        try {
/*@egen*/ //System(dsada)
	<CALL> name = Identifier() (Identifier())* <LPAREN>(Parameters())*<RPAREN><SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* ClassInstantiation defines how a class must be instantiated
* @accepts instantiate CLASSNAME VARIABLE(PARAMETERS); e.g. instantiate LCDDisplay lcd();
* @hint the class instantiation can consist of zero parameters
**/
void ClassInstantiation()                     : {/*@bgen(jjtree) ClassInstantiation */
  ASTClassInstantiation jjtn000 = new ASTClassInstantiation(JJTCLASSINSTANTIATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassInstantiation */
        try {
/*@egen*/
	<INSTANTIATE> Identifier() (Identifier())* <LPAREN>(Parameters())*<RPAREN><SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Parameters defines how parameters must be defined, and what to return to the PrintVisitor
* @accepts NUMBER or NUMBER (("," | "%" | "*" | "/" | (+ | -)) PARAMETER)* - It is concatenated 
* @accepts STRINGTEXT or STRINGTEXT (, PARAMETER)* - Concatenated
* @accepts IDENTIFIER or IDENTIFIER (, PARAMETER)* - Concatenated
* @param Token t, this is the token that is sent to the PrintVisitor
* @param String text, this is used for the String and Identifier to sent the data to the PrintVisitor class.
**/
void Parameters()            : {/*@bgen(jjtree) Parameter */
                                ASTParameter jjtn000 = new ASTParameter(JJTPARAMETER);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String text;}
{/*@bgen(jjtree) Parameter */
        try {
/*@egen*/
	((t = Number()((("," | <MOD> | <MULTIPLY> | <DIVISION> | <ADD_OP>) Parameters())*)/*@bgen(jjtree)*/
                                                                                          {
                                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                                            jjtc000 = false;
                                                                                          }
/*@egen*/{jjtn000.value = t;}
|	(text = StringText()("," Parameters())*)/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn000, true);
                                                  jjtc000 = false;
                                                }
/*@egen*/{jjtn000.value = text;}
|	(text = Identifier()("," Parameters())*)/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn000, true);
                                                  jjtc000 = false;
                                                }
/*@egen*/{jjtn000.value = text;}
))/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Term
* @accepts NUMBER or IDENTIFIER
**/
void Term()       : {}
{
	(Number() | Identifier())
}

Token BooleanNumber() : {/*@bgen(jjtree) BooleanNumber */
                         ASTBooleanNumber jjtn000 = new ASTBooleanNumber(JJTBOOLEANNUMBER);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) BooleanNumber */
        try {
/*@egen*/
	t = <POSITIVENUMBER>/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/ {jjtn000.value = t.image; return t;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Number - this is defining how all the numbers in the language has to be defined
* @accepts <INTEGER_LITERAL> 
* @accepts <FLOATING_POINT_LITERAL>
* @return Token t - this is used by other methods
**/
Token Number() : {/*@bgen(jjtree) Number */
                  ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Number */
        try {
/*@egen*/
	(
		t = <INTEGER_LITERAL>/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/ {jjtn000.value = t.image; return t;}
		| t = <FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                               }
/*@egen*/ {jjtn000.value = t; return t;}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* StringText defines how strings has to be defined. 
* @accepts e.g. "Hello World!" do not accept: Hello World!
* @return String t.image
**/
String StringText() : {/*@bgen(jjtree) StringText */
                       ASTStringText jjtn000 = new ASTStringText(JJTSTRINGTEXT);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) StringText */
        try {
/*@egen*/
	t = <STRING_LITERAL>/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
* Identifier - is used by other methods where text has to be written but without \"".. e.g. Print, or variable names.
* @accepts <ID>
* @return String t.image
**/
String Identifier() : {/*@bgen(jjtree) Identifier */
                       ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
	t = <ID>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


